## Next steps

Get the visualizer working with non-category scenarios (single category, each scenario a "level")

Check that all ScenarioElements are being added to all model stages in these cases:
  1. Standard reportable model scenarios
  2. Model Stages defined from ScenarioDir (manual)
  3. Model Stages defined from ScenarioDir (categories)
     a. StartFrom in Base Model
     b. StartFrom in ScenarioCategories (Base Model)
     c. StartFrom in ScenarioCategories (Scenario ModelStage)

Later, in the tests.R, modify those base model settings to introduce/handle some errors and
  to do the partial specifications described below.

#### Implement the Files function and "build" (to install default files for levels/scenarios)

Can create both for manual scenarios and category scenarios.

add nuance to "files" function; if we're doing manual scenarios, then we need
  to add a Files key to visioneval.cnf for the manual scenario - those will be copied
  if present when we build the scenario (but unchanged if they already exist - eventually
  compare the files to the BaseModel/InputPath version).
  Files key in visioneval.cnf will be loaded and saved.
  If the Files key exists, those are the "scenario files" - so the files function
    should have a flag to indicate what category or scenario we're getting the files
    for (and which levels have files, and which are different from each other and the
    BaseModel/StartFrom stage).

###### Concrete steps

These should be tested out in "test_scenarios" in tests/test.R.

    Are ScenarioCategories defined:
      No: Create a default ScenarioCategory called "Scenarios". Create a default ScenarioElement
          called "Scenario". Create ScenarioCategory Levels keyed one-to-one to ScenarioElement
          "Scenario" Levels, which are in turn built from each ModelStage plus StartFrom defined
          in the scenario section.
    If one ScenarioCategory is defined, does it have defined Category Levels?
      No: Just like default, except we've named the Category (for the Visualizer)
    If it has defined Category Levels, does each of those have a ScenarioElement Level
      No: Error; each category level has to be associated with one or more ScenarioElement Levels
      CategoryLevel can also include a Name (default is definition sequence) and Description
      Level includes a list of one more more ScenarioElement/Level pairs. The ScenarioElement/Level
      can only appear in one CategoryLevel.
    If Category Level has ScenarioElement Levels, do we have a ScenarioElement structure
      No: Just like default, but interpret ScenarioElement Levels as scenario ModelStage names,
      and only include those explicitly named model stages in visualization (ignore the rest)
    If the ScenarioElement structure is defined, are the ScenarioElements permutable
      Requirement: has Files defined for each ScenarioElement. Directories attached to each
        element have (error) all and only those Files and (warning) at least one directory
        file differs among each of the levels.
      No: If Files descriptor is missing, exactly one ScenarioELement Level is allowed. The Level
          Name must belong to a scenario ModelStage. The ScenarioElement will supply descriptive
          information (rather than interpolating ModelStage values)
    Does each ScenarioElement Level appear in either zero or exactly one ScenarioCategory Level?
      No: error
    Permute the ScenarioCategory Levels and generate a summary of each resulting ModelStage
      (including the StartFrom) - provides documentation of what is being run.
      Permutation should work even if there is just one ScenarioCategory (permutations are based
      on InputPaths associated with each ScenarioElement Level)
      ModelStage must include ScenarioElement Name:Value pairs for each ScenarioElement Level
        included in the permuted ModelStage. A Name:Value pair is added for each ScenarioElement, if
        a non-zero Level for that ScenarioElement does not appear in the permutation (missing), then
        the Value is zero. Might start by making them all zero, then just dropping in the permuted
        non-zero values.

VEModel Adjustments

  - Need to update the "dir" and "clear" functions for the model to manage queries. QueryDir
    contains query templates. They are not managed by "clear" which looks only at results.
    Need to recognize queries in the ResultsDir and treat those like log files with respect to
    listing and clearing. Clearing results will take out the QueryRun-*.Rda along with Logs.
    The Query outputs are .Rda files called QueryRun-<QueryName>.Rda where the QueryName is
    same one that was loaded to run the query.
  - VEQuery uses an attached model to manage query results (and we can call up results - which
    internally calls run if there are no results yet). Do VEQuery$results to get results (report "No
    Model" if a model is not attached; report "Model run status: X" if the model is not "Run
    Complete").
  - Accessing a query through a model automatically attaches the model. Otherwise use
    VEQuery$model(VEModel object) to attach. Opional Save parameter will create QueryDir for the
    model (if it doesn't exist) and save to VEQuery name if there is no corresponding .VEqry yet.
  - Archiving Results should also archive query results (like Log files) - and outputs should also
    probably come along for the ride generally.
  - Copying a model has the option to copy its results and dataset. If we have the model name in
    the results ModelState.Rda, it needs to change, as does the ModelDir and everything derived from
    it - that's also the case with just archiving the results (make sure RunPath is correct - the
    archive should look just like results that were genereated if ResultsDir = ArchiveDir).
  - Suggests we need a function to operate on the ModelState and fix everything up (certain
    parameters get replaced and rebuilt).

[DONE] The model's "$scenarios" function returns a VEModelScenarios object
  Pointer to the BaseModel
  StartFrom stage
  ScenarioDir (relative to model$modelPath, snapshot of BaseModel$setting("ScenarioDir"))
    NULL if ScenarioDir does not exist
  ScenarioConfig (snapshot of BaseModel$setting("ScenarioConfig") name)
    NULL if ScenarioConfig does not exist
  Option to create ScenarioDir and blank ScenarioConfig (create=TRUE)
  Option to force reload (fromFile) or skip file reload
Printing the scenarios object will say if scenarios are defined.
  [DONE] VEModelScenarios$initialize(BaseModel,create=FALSE,startFrom=NULL)
    BaseModel is required (search for ScenarioDir)
    Populate the scenario structure
      BaseModel, StartFrom, ScenarioDir, ScenarioConfig (nail it down at the moment of creation)
    If create==TRUE, build ScenarioDir and add ScenarioConfig
      Pull startFrom from BaseModel if create==TRUE and not provided (last Reportable stage)
    If create==FALSE, just consider what is (not) there
    Does $load if ScenarioDir exists or got created (ScenarioConfig may or may not exist)
  [DONE] VEModelScenarios$load(StartFrom=NULL,build=TRUE,scenarioPath=NULL)
    Option to (re)set "StartFrom" if provided (forces build to TRUE)
    Will load "scenarios.cnf" if it exists in ScenarioDir and extract "Scenarios" key
    If "Scenarios" key does not exist, create it and resave scenarios.cnf
      Contains ScenarioDir, StartFrom (may be reset during loading)
    Use Categories key if present, but don't build/create automatically
    Can optionally specify "build" to try constructing ModelStages
      Model stages will be rebuilt from what is in scenarios.cnf in this case
      If $build fails, report what is missing
      If $build succeeds
        replace ModelStages
        reload the baseModel (which will add the scenarios to its stages)
    Otherwise note in print/status that ModelStages have not been built
    If build==TRUE, also rewrite ScenarioDir/ScenarioConfig with any built changes.
  [DONE] VEModelScenarios$save(overwrite=FALSE)
    Save the in-memory scenario configuration back to ScenarioDir/ScenarioConfig
    Use as an alternative (and perhaps call from within) to the Save=TRUE option on $load, $files, $build
    Nuance the overwrite flag appropriately
  [DONE] VEModelScenarios$stages(scenarios=NULL)
    Return the built list of stages (or an empty list) as VEModelStage objects
    TODO: May filter that list by scenario (stage) name, perhaps also by category (just stages
      using a certain category) and further by level (just stages using a certain level)
  VEModelScenarios$run
    Dispatches to the model run, with option to list specific scenarios to run
      Scenarios to run are listed by name (see $stages object to get the names)
    Includes option to "save", "reset" or "continue" (with, in this case, "reset" being the default)
  VEModelScenarios$print()
    Indicate type of scenarios (folders, category-based)
    Indicate how many scenarios are defined
    List Folder-based scenarios
    List Categories/Levels, plus number of generated scenarios
  VEModelScenarios$inputs(scenario or category name; default all of them)
    Return StartFrom inputs that have been defined in the requested (default: ALL) scenario or categories
    Option to show all files (default for full scenario - looks at BaseModel/StartFrom inputs)
      or just those defined in the scenario/category (looks at files named in the category)
      For categories, will say if the file belongs to the category (perhaps also report levels in which the file actually exists)
      For scenarios, will say if the file exists in the scenario directory
    Validate category inputs - file can only occur in one category
    For directory based scenarios
  VEModelScenarios$fromCSV(CSVFile="scenario_categories.csv")
    # Simpler function just to parse CSV files set up the "old way" (see VEScenario)
    # Converts the spreadsheet into "Categories" key in the scenario description
    Read that file to determine categories to attach to the Input files
    Flag any inputs in the CSV that are not in the StartFrom Stage
    Return constructed "Category" key
    Return the Category_df from the CSV file
    If Save is true, save Category_df to CSVFile
    Don't change anything if the CSV does not have a valid configuration
  VEModelScenarios$categories(levels=FALSE)
    Return the Category names (for use, e.g. in examining inputs)
    If levels==TRUE, return a named list of character vectors
      Each list element is named for its category
      The character vector contains the names of the levels
    Usual workflow:
      Update the Category key (a nested named list, or via the CSV)
      Save the VEScenarios back out to to scenarios.cnf
      Re-load the scenarios object (build=TRUE)
  VEModelScenarios$build(Reset=FALSE,Save=TRUE)
    Main activity of "build" is to construct ModelStages from the scenarios identified in scenario.cnf
    Handle two types of scenarios (Categories and Folders)
      Process "Folders" first
      If "Categories" tag is present, holds a Category/Level structure
        Optional StartFrom as the first element of Categories; may refer to a Folder scenario
        Subsequent elements are names with Files and Levels
        Process the combinations into ModelStages structures
      if "ScenarioFolders" tag is present, is a list of directories to treat as scenarios
        else generate ScenarioFolders from sub-directories of ScenarioDir (like VEModel$configure)
        Process directories into ModelStages structures
    If Reset is TRUE:
      Ignore existing ModelStages - otherwise just check for additions/consistency
    If Save is TRUE
      Resave scenario.cnf with ModelStages added
    If Save is FALSE
      Just leave ModelStages in memory (for debugging/inspection)
    The "load" function turns the ModelStages description for the Scenarios into VEModelStage objects (after build)
    Folders are always processed first, then Categories
    If processing Folders:
      ModelStages will just use each of the ScenarioFolders as "StageDir" for the stages
      If the sub-directory has a visioneval.cnf, set StageConfig instead
      Names of sub-directories will be Names of scenario stages (must be unique relative to Model)
      All the ScenarioFolders will StartFrom the overall scenario StartFrom
      StartFrom need not be provided (in which case the Scenario folders must be runnable - error
        will be generated when we attempt to reload the model in which the scenarios live)
    If processing Categories
      CategoryStartFrom (can refer to a Folder scenario)
        Defaults to overall scenario StartFrom
        If provided, it must refer to the name of a Folder scenario within this scenario set
        If the name is not a folder within the scenario set, offer a warning and ignore it
        If no StartFrom available, then an error (missing "StartFrom")
      Categories structure is an array
        NOTES (ignored)
        NAME
        LABEL
        DESCRIPTION
        INSTRUCTIONS
        FILES
        LEVELS
          NAME
          NOTES (ignored)
          LABEL
          DESCRIPTION
        Files
          Must be inputs to StartFrom stage, must be unique across all Categories
        Levels
          Name (short, for reports and output folder)
          Description (describing intent)
          Notes (ignored)
      Proceed to complete the Category build (below)
    Complete the Category build: After doing table or config build setup, complete as follows:
      Validate categories:
        Each category must have at least one additional level
          StartFrom is the implied base scenario level for all categories
        Each category must specify at least one file
        Each file from StartFrom input must exist in at most one category
      Create any Category-Level folders that do not exist
        Make folders for each Category (create if not existing)
          Make folders for each Level (create if not existing)
      Install the Category files from StartFrom InputPath into each Level folder
        If the file is present, just skip it
        If a file not in the Category is present in a level, warn the user and stop the build
        If a file is not present, copy it from the StartFrom InputPath
      Build the ModelStages structure for Categories
        Make a Scenarios/ModelStage entry for each combination of Category-Level
        Name constructed from index of Category and Level (C1L2C2L3)
          The stages are just the scenarios
          The StartFrom stage corresponds to C1L0C2L0 but is not identifed that way
        Set up InputPath (vector of Category-Level folders), Scenario, Description, ScenarioDir (for output)
          # The ModelStages structure placed in the Model's Scenarios key:
          # Should end up defining for each scenario (ModelStage):
          #   Name (of stage; defaults to basename(Dir) )
          #   Dir (compound name for stage, for ResultsDir; or folder if scenario is folder-based )
          #   Scenario (or Name or basename(Dir)) - used for Query column headings
          #   Description (Category + Level Descriptions): could end up REALLY long...
          #   InputPath (compounded as path to CategoryLevel subdirectories relative to
          #     BaeModel$modelPath/ScenarioDir) - should normalize when Scenario stages are loaded.
          #   Reportable (always TRUE)
          #   Additional configuration can be provided by hand for Category scenarios
          #   Manual scenarios can be adjusted through their own visioneval.cnf
        Goes straight into ModelStages (rewrite ModelStages structure)
    If Save, rewrite scenarios.cnf
    If not Save, then just keep the scenario object up to date in memory (can call VEModelScenarios$save)

============================

  Scenario stages are appended after the last regular ModelStage (note that the scenarios are
  automatically considered Reportable, and we don't alter Reportable for any "StartFrom" stage).
  Also require unique names for the scenarios. If scenario configuration is broken, just do a
  warning. Warn if model has no scenarios at all.

  Helper functions for VEModelScenario. Figure out how to interact these with the "build"
    function: probably these should just help make templates.
  VEModelScenarios$categories()
    # Report if using directory-based (manual) scenarios
      # Each scenario folder is a "Category"
    # If category-based:
      # Report the Categories key from Scenarios key, if present, else "No categories defined"
  VEModelScenarios$list()
    # Reports the ModelStages (Scenario names, possibly with Description)
    # Works for both category-based and manual scenarios
    # Or should it report a vector of VEModelStages - the latter is more flexible
    #   and could support the internal operation of creating the group of scenarios
    #   to run.
    # Picking a "stage" for producing a directory or finding out about it should look
    #   not just into the model's intrinsic ModelStages but also into the Scenarios$ModelStages

  In the VEModel print function, we need to distinguish scenario model stages from those that
    are intrinsic to the base model. We can do that by factoring out ModelStages whose names
    are present/not present in the scenario list
